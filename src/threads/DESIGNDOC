+----------------------+
| SISTEMAS DE OPERAÇÃO |
|                      |
|  PROJECTO O1         |
|  DESIGN DOCUMENT     |
+----------------------+

---- GROUP ----
Nuno Gomes <p111082@campus.fct.unl.pt>
Serhiy Moskovchuk <??@campus.fct.unl.pt>


---- PRELIMINARIES ----
Appendix D: Project Documentation
100
>> If you have any preliminary comments on your submission, notes for
>> the TAs, or extra credit, please give them here.
(This is a sample design document.)
>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation,
>> course text, and lecture notes.
None.


JOIN
====
---- DATA STRUCTURES ----
>> Copy here the declaration of each new or changed ‘struct’ or ‘struct’
>> member, global or static variable, ‘typedef’, or enumeration.
>> Identify the purpose of each in 25 words or less.

TIMER_SLEEP
    Foi adicionado à estrutura thread um campo com a altura (ticks) para
    a thread ser considerada de novo como "ready", wakeup_tick. Este campo vai
    conter um valor dado pelo tempo actual mais o periodo de espera.



---- ALGORITHMS ----
TIMER_SLEEP

Na thread que invoca o metodo timer_sleep(int64_t), é invocado o método
thread_sleep que actualiza o campo da estrutura thread que guarda o tick no qual
a thread deve voltar a ser considerada ready. Logo de seguida é bloqueada usando
a função fornecida thread_block. A cada ciclo de relógio a rotina que trata o
interrupt gerado pelo timer chama o metodo thread_tick, neste método vão ser
percorridas todas as threads existentes. Cada uma vai ser verificado o seu
estado e se precisam de ser acordadas, recolocando-as na lista ready se for o
caso utilizando o metodo thread_unblock.






---- SYNCHRONIZATION ----
Consider parent thread P with child thread C. How do you ensure
proper synchronization and avoid race conditions when P calls wait(C)
before C exits? After C exits? How do you ensure that all resources
are freed in each case? How about when P terminates without waiting,
before C exits? After C exits? Are there any special cases?
C waits in thread_exit() for P to die before it finishes its own
exit, using the can_die semaphore "down"ed by C and "up"ed by P as
it exits. Regardless of whether whether C has terminated, there
is no race on wait(C), because C waits for P’s permission before
it frees itself.

---- RATIONALE ----
>> Critique your design, pointing out advantages and disadvantages in
>> your design choices.
Numa primeira versão foi tentado criar uma lista ordenada pelo tempo em que a
thread iria acordar. Tento tido alguns problemas com esta versão foi utilizada
a função thread_foreach, e a cada thread verificar se esta é uma thread
adormecida e verificar se está na altura de a considerar ready.
